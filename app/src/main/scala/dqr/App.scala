/*
 * This Scala source file was generated by the Gradle 'init' task.
 */
package dqr

 // java -cp "jars/driver/aws-java-sdk-bundle-1.12.20.jar:jars/driver/ImpalaJDBC41.jar:/usr/share/scala/lib/scala-library.jar:target/scala-2.11/dqr1_2.11-1.0.jar" DQR

// /* dqr.scala */

import java.sql.{Connection, ResultSet, SQLException, Statement, DriverManager}
import scala.collection.JavaConversions._
import scala.util.{Try,Success,Failure}
import scala.io.{Source}
import java.util.Properties

import com.amazonaws.auth.DefaultAWSCredentialsProviderChain
import com.amazonaws.regions.Regions
import com.amazonaws.services.s3.AmazonS3ClientBuilder
import com.amazonaws.services.s3.model._
import com.amazonaws.client.builder.AwsClientBuilder
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import scala.language.postfixOps

case class Rule(maserID:Int, ruleID: Int, paramf:String, granularf:String, summaryf: String, timeout_second: Int)


object App {
  def main(args: Array[String]) {
    Log.logger.info("Starting...")

    val appPar = Config.getAppParmeter(args)
    Log.logger.info(s"batch_id = ${Config.batchID}")
    Log.logger.info(s"App Parameter(groupNo, datekeyExtra, level, rule_ids)=${appPar}")
    
    // sys.exit(0)
    
    Try{
      val engine = new QueryEngine(Config.getProperty("impala.connection"))
      val s3engine = new S3Engine(Config.getProperty("aws.s3.endpoint"))

      getRules(engine, appPar) foreach {r=> 
        val task = new DQTask(r, engine, s3engine, appPar)
        task.run()
        //  match {
        //   case Failure(exception) => 
        //     Log.logger.warn(s"error in ruleID= ${r.ruleID}=${r}. error: $exception"); 
        //   case Success(value) => 
        //     Log.logger.info(s"success in ruleID=${r.ruleID}")
        // }
      }
      (engine, s3engine)
    } match {
      case Success((engine, s3engine)) => 
        engine.close()
        Log.logger.info("DQR has finished all rules.")
      case Failure(e) => 
        Log.logger.error(s"error in DQR App: $e")
    }
    Log.logger.info(s"DQR completed. batch_id=${Config.batchID}")
  } // end main

  def getRules(engine: QueryEngine, appPar: AppParameter): List[Rule] = {
    val query = Config.getProperty("dq.rule.query").stripMargin +
      (if(appPar.groupNo != Config.ALL_GROUP) s" AND group_no = ${appPar.groupNo}" else "") +
      (if(appPar.ruleIDs.length>0) s" AND rule_id IN (${appPar.ruleIDs.map(_.toString).mkString(",")})" else "")

    engine.read(query) map {
      case null => List[Rule]()
      case rs =>
        val data = Iterator.continually(rs.next())
          .takeWhile(identity)
          .map(_ => 
              Rule(rs.getInt("master_id"),
                rs.getInt("rule_id"),
                Option(rs.getString("param_sql_file")).getOrElse("").trim,
                Option(rs.getString("granular_sql_file")).getOrElse("").trim,
                Option(rs.getString("summary_sql_file")).getOrElse("").trim,
                Option(rs.getInt("timeout_second")).getOrElse(0)
              )
          ).toList.sortWith((a,b) => if(a.maserID < b.maserID) a.ruleID < b.ruleID else false)
        rs.close()

        Log.logger.debug(s"rules read = $data")
        data
    } match {
      case Failure(exception) => throw new Exception(s"failed to load rules. error: $exception")
      case Success(v) => v
    }
  } // end getRules
} // end class App

class QueryEngine(url: String) {
  Class.forName("com.cloudera.impala.jdbc41.Driver")
  val connection = DriverManager.getConnection(url)
  val statement = connection.createStatement()
  statement.executeUpdate(Config.getProperty("impala.init.query"))

  def close() {
    connection.close()
  } // end close

  def read(query: String) = Try{
    Log.logger.debug(s"query =$query")
    if(!query.isEmpty) {
      statement.setQueryTimeout(0)
      statement.executeQuery(query)
    } else
      null
  } // end read

  def write(query: String, timeout:Int=0) = Try{
    Log.logger.debug(s"query =$query")
    if(!query.isEmpty) {
      statement.setQueryTimeout(timeout)
      statement.executeUpdate(query)
    } else
      null
  } // end write
} // end class QueryEngine

class S3Engine(endpoint:String) {
  val s3Client = AmazonS3ClientBuilder.standard()
    .withEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration(
      endpoint, Regions.DEFAULT_REGION.name() ))
    .withCredentials(new DefaultAWSCredentialsProviderChain) 
    .withPathStyleAccessEnabled(true)
    .build()

  def readFile(uriString: String):Try[String] = Try{
    if(uriString.isEmpty)
      ""
    else {
      val uri = new java.net.URI(uriString)
      val obj = s3Client.getObject(uri.getHost, uri.getPath.substring(1))
      val objData = obj.getObjectContent
      val data = scala.io.Source.fromInputStream(objData).mkString
      objData.close()
      data
    }
  } // end readFile
} // end calss S3Engine

class DQTask(rule: Rule, engine: QueryEngine, s3engine: S3Engine, appPar: AppParameter) {
  def getSqlParam():Try[Map[String, String]] = {
    s3engine.readFile(rule.paramf) flatMap {sql =>
      if(sql.isEmpty)
        Success(Map[String, String]())
      else {
        engine.read(sql.replace("{{datekey_extra}}", appPar.datekeyExtra.toString)) map {rs =>
          val params = rs.next match {
            case true => 
              val rsmd = rs.getMetaData();
              val cols = (1 to rsmd.getColumnCount) map (rsmd.getColumnName(_).toLowerCase)
              cols zip (1 to cols.size).map(rs.getString(_)) toMap
            case false => Map[String, String]()
          }
          rs.close()
          Log.logger.debug(s"query parameters=${params}")
          params
        }
      }
    }
  } // end getSqlParam

  def combineSql(ruleLevel: Int)(params: Map[String, String]) = {
    val exceptf = if(ruleLevel == Config.GRANULAR_RULE_LEVEL) rule.granularf else rule.summaryf
    s3engine.readFile(exceptf) map {sql =>
      if(sql.isEmpty)
        ""
      else {
        val org = params.foldLeft(sql) {case (acc, (k,v))=> acc.replaceAll("(?i)\\{\\{" + k + "}}",v)}
        if(ruleLevel == Config.SUMMARY_RULE_LEVEL)
          s"""INSERT INTO ${Config.getProperty("dq.exception.summary.table")} 
          | (exception_id, rule_id, data_effective_dt, exception_value, expected_value, total_count, error_count, source_application, application_job_name, except_dt) 
          | PARTITION(datekey=${params("datekey")} , batch_id=${Config.batchID})
          | SELECT '${Config.getID}', ${rule.ruleID}, data_effective_dt, exception_value, expected_value,  total_count, error_count, 
          | '${Config.sourceApplication}', '${Config.applicationJobName}', except_dt
          | FROM (${org.replace("$;*\\s*", "")}) org""".stripMargin
        else
          s"""INSERT INTO ${Config.getProperty("dq.exception.granular.table")}
          | (exception_id, rule_id, primary_column_values, data_effective_dt, element_value, exception_output_column_values, source_application, application_job_name, except_dt)
          | PARTITION(datekey=${params("datekey")} , batch_id=${Config.batchID})
          | SELECT '${Config.getID}', ${rule.ruleID}, primary_column_values, data_effective_dt,
          | element_value, exception_output_column_values,
          | '${Config.sourceApplication}', '${Config.applicationJobName}', except_dt FROM (${org.replace("$;*\\s*", "")}) org""".stripMargin
      }
    }
  } // end combineSql

  def insertException(params: Map[String, String])(getSql: (Map[String, String])=> Try[String]) =  {
    val res = getSql(params).flatMap(engine.write(_, rule.timeout_second))
    res
  }

  def updateAudit(datekey: Int, level: Int, status: Int) = {
    engine.write(s"""INSERT INTO ${Config.getProperty("dq.audit.table")}(rule_id, datekey, batch_id, rule_level, status, created_dt) VALUES
      | (${rule.ruleID}, ${datekey}, ${Config.batchID}, ${level}, ${status}, NOW())""".stripMargin) match {
        case Success(v) => v
        case Failure(e) => Log.logger.warn(s"failed to update audit table for rule=$rule, actual level=$level, datekey=$datekey, status=$status, error: $e")
      }
  }
  
  def run() = getSqlParam().map{par => 
    val datekey = par("datekey").toInt  
    if(appPar.ruleLevel == Config.GRANULAR_RULE_LEVEL || appPar.ruleLevel == Config.BOTH_RULE_LEVEL) {
      updateAudit(datekey, Config.GRANULAR_RULE_LEVEL, Config.RUN_START_STATUS)

      insertException(par)(combineSql(Config.GRANULAR_RULE_LEVEL)_) match {
        case Success(_) => 
          Log.logger.info(s"Granular exception of rule ${this.rule} is created successfully."); 
          updateAudit(datekey, Config.GRANULAR_RULE_LEVEL, Config.RUN_SUCCESS_STATUS) 
        case Failure(e) => Log.logger.warn(s"Granular exception of rule ${this.rule} failed to be created. error: ${e}") 
          updateAudit(datekey, Config.GRANULAR_RULE_LEVEL, Config.RUN_FAILURE_STATUS)
      }
    }
    
    if(appPar.ruleLevel == Config.SUMMARY_RULE_LEVEL || appPar.ruleLevel == Config.BOTH_RULE_LEVEL) {
      updateAudit(datekey, Config.SUMMARY_RULE_LEVEL, Config.RUN_START_STATUS)

      insertException(par)(combineSql(Config.SUMMARY_RULE_LEVEL)_) match {
        case Success(_) => 
          Log.logger.info(s"Summary exception of rule ${this.rule} is created successfully.") 
          updateAudit(datekey, Config.SUMMARY_RULE_LEVEL, Config.RUN_SUCCESS_STATUS) 
        case Failure(e) => 
          Log.logger.warn(s"Summary exception of rule ${this.rule} failed to be created. error: ${e}")
          updateAudit(datekey, Config.SUMMARY_RULE_LEVEL, Config.RUN_FAILURE_STATUS)
      }
    }
  } match {
    case Success(_) => Log.logger.info(s"Successfully processed rule ${this.rule}.") // No audit as it has been added to audit above
    case Failure(e) => Log.logger.warn(s"Failed to run parameter/exception query for rule ${this.rule}. error: ${e}")
      // if ruleLevel=both, audit parameter failure
      updateAudit(-1, appPar.ruleLevel, Config.RUN_PARAMETER_FAILURE)
  }
} // end class DQTask
